<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.ico" />
    <title>SNAP Map - Interactive Map Visualization by Kiron Ang</title>
    <style>
        :root {
            --primary-color: #7e212a;
            --background-color: #a47764;
            --light-color: #ffb082;
            --border-color: #d3b8ae;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--background-color);
            color: var(--primary-color);
            line-height: 1.5;
            padding: 1rem;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        header {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 1rem;
        }

        .title-container {
            background-color: var(--light-color);
            padding: 0.5rem 1.5rem;
            border-radius: 30px;
            text-align: center;
            margin: 0 auto;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            gap: 1rem;
        }

        .map-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1/1;
            max-height: 70vh;
        }

        .map-container svg {
            background-color: var(--light-color);
            border-radius: 8px;
            width: 100%;
            height: 100%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .sidebar {
            background-color: var(--light-color);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            max-height: 50vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        .sidebar h2 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .store-item {
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .store-name {
            font-weight: bold;
            font-size: 1.1em;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--primary-color);
            border-radius: 5px;
            padding: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 250px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            color: var(--primary-color);
            font-size: 0.9rem;
            z-index: 1000;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 0.25rem;
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 0.25rem;
        }

        .instructions {
            font-style: italic;
            margin-bottom: 1rem;
        }

        @media (min-width: 768px) {
            .main-container {
                flex-direction: row;
            }

            .map-container {
                flex: 2;
                max-height: 80vh;
            }

            .sidebar {
                flex: 1;
                max-height: 80vh;
            }
        }

        /* Focus styles for accessibility */
        :focus {
            outline: 3px solid #f1a7cd;
            outline-offset: 2px;
        }

        /* High contrast mode support */
        @media (forced-colors: active) {
            .sidebar, .title-container, .map-container svg {
                border: 1px solid ButtonText;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="title-container">
            <h1>SNAP Map</h1>
        </div>
    </header>
    <main class="main-container">
        <div class="map-container" id="map-container" aria-label="Map of SNAP retailers">
            <!-- SVG will be inserted here by JavaScript -->
        </div>
        <div class="sidebar">
            <h2>Ten Closest SNAP Retailers:</h2>
            <p class="instructions" id="map-instructions">Tap on the map to find the closest SNAP retailers.</p>
            <div id="closest-stores" aria-live="polite"></div>
        </div>
    </main>

    <div id="tooltip" class="tooltip" role="tooltip" aria-hidden="true">
        <div class="tooltip-title"></div>
        <div class="tooltip-content"></div>
    </div>

    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

        // Set up map
        const mapContainer = document.getElementById("map-container");
        const svg = d3.create("svg")
            .attr("aria-label", "Interactive map of SNAP retailers")
            .attr("role", "img");
        
        mapContainer.appendChild(svg.node());
        
        // Create a group for all map elements
        const g = svg.append("g");
        
        // Setup tooltip
        const tooltip = d3.select("#tooltip");
        
        // Point settings
        const POINT_RADIUS = 3;
        const HIGHLIGHT_RADIUS = 5;
        
        // Track if we're currently processing a click to prevent multiple rapid clicks
        let isProcessing = false;
        
        // Load data - using fetch API for better performance
        fetch("data.csv")
            .then(response => response.text())
            .then(csvText => {
                // Simple CSV parsing to avoid full d3.csv parser overhead
                const rows = csvText.trim().split('\n');
                const headers = rows[0].split(',');
                
                const data = rows.slice(1).map(row => {
                    const values = row.split(',');
                    const entry = {};
                    
                    headers.forEach((header, i) => {
                        // Convert numeric values
                        const value = values[i];
                        if (header === 'X' || header === 'Y') {
                            entry[header] = parseFloat(value);
                        } else {
                            entry[header] = value;
                        }
                    });
                    
                    return entry;
                });
                
                // Pre-calculate data extents to avoid repeated calculations
                const xExtent = [
                    Math.min(...data.map(d => d.X)),
                    Math.max(...data.map(d => d.X))
                ];
                
                const yExtent = [
                    Math.min(...data.map(d => d.Y)),
                    Math.max(...data.map(d => d.Y))
                ];
                
                // Prepare SVG points in a more efficient way
                setupMapPoints(data, xExtent, yExtent);
            })
            .catch(error => console.error("Error loading data:", error));
            
        function setupMapPoints(data, xExtent, yExtent) {
            // Initial render
            requestAnimationFrame(() => updateMapSize(data, xExtent, yExtent));
            
            // Add resize handler with debounce
            let resizeTimer;
            window.addEventListener("resize", () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    updateMapSize(data, xExtent, yExtent);
                }, 250);
            });
            
            // Touch event optimization for mobile
            let touchTimer;
            svg.node().addEventListener("touchstart", (event) => {
                // Clear any existing timer
                clearTimeout(touchTimer);
                
                // Prevent default to avoid double events
                event.preventDefault();
                
                if (isProcessing) return;
                
                // Set a timeout to handle the touch after a short delay
                touchTimer = setTimeout(() => {
                    const touch = event.touches[0];
                    const rect = svg.node().getBoundingClientRect();
                    const touchX = touch.clientX - rect.left;
                    const touchY = touch.clientY - rect.top;
                    
                    handleMapInteraction(data, touchX, touchY, xExtent, yExtent);
                }, 50);
            }, { passive: false });
            
            // Regular click handler for desktop
            svg.on("click", function(event) {
                if (isProcessing) return;
                
                const [clickX, clickY] = d3.pointer(event);
                handleMapInteraction(data, clickX, clickY, xExtent, yExtent);
            });
        }
        
        function updateMapSize(data, xExtent, yExtent) {
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Calculate margins
            const margin = Math.min(containerWidth, containerHeight) * 0.05;
            
            // Create scales
            const x = d3.scaleLinear()
                .domain(xExtent)
                .range([margin, containerWidth - margin]);
            
            const y = d3.scaleLinear()
                .domain(yExtent)
                .range([containerHeight - margin, margin]);
            
            // Batch DOM operations for better performance
            const circles = [];
            
            // Create a document fragment to minimize reflows
            const batch = 500; // Process in batches for better performance
            const totalBatches = Math.ceil(data.length / batch);
            
            // Clear existing circles
            g.selectAll("circle").remove();
            
            // Process in batches
            for (let b = 0; b < totalBatches; b++) {
                const start = b * batch;
                const end = Math.min(start + batch, data.length);
                const batchData = data.slice(start, end);
                
                // Create circles for this batch
                const batchCircles = g.selectAll(null)
                    .data(batchData)
                    .enter()
                    .append("circle")
                    .attr("cx", d => x(d.X))
                    .attr("cy", d => y(d.Y))
                    .attr("r", POINT_RADIUS)
                    .attr("fill", "#7e212a")
                    .attr("tabindex", 0)
                    .attr("aria-label", d => `${d.Store_Name}, ${d.Store_Type}`)
                    .attr("role", "button");
                
                // Add event handlers only to a smaller subset for performance
                batchCircles.each(function(d) {
                    const circle = d3.select(this);
                    circle.on("click", function(event) {
                        if (isProcessing) return;
                        event.stopPropagation();
                        handleMapInteraction(data, x(d.X), y(d.Y), xExtent, yExtent);
                    });
                });
            }
        }
        
        function handleMapInteraction(data, pixelX, pixelY, xExtent, yExtent) {
            isProcessing = true;
            
            // Show loading indicator in sidebar
            document.getElementById("closest-stores").innerHTML = "<p>Finding closest stores...</p>";
            
            // Use a timeout to allow UI to update before heavy computation
            setTimeout(() => {
                const containerWidth = mapContainer.clientWidth;
                const containerHeight = mapContainer.clientHeight;
                const margin = Math.min(containerWidth, containerHeight) * 0.05;
                
                // Create scales
                const x = d3.scaleLinear()
                    .domain(xExtent)
                    .range([margin, containerWidth - margin]);
                
                const y = d3.scaleLinear()
                    .domain(yExtent)
                    .range([containerHeight - margin, margin]);
                
                // Convert pixel coordinates to data space
                const dataX = x.invert(pixelX);
                const dataY = y.invert(pixelY);
                
                findClosestPoints(data, dataX, dataY, x, y);
            }, 50);
        }
        
        function findClosestPoints(data, x, y, xScale, yScale) {
            // Calculate distances
            const closestPoints = [];
            
            // First pass: Calculate distances and keep track of the 10 closest
            let maxDist = Infinity;
            
            data.forEach(d => {
                // Reset highlight state
                d.highlighted = false;
                
                const dist = Math.sqrt(Math.pow(d.X - x, 2) + Math.pow(d.Y - y, 2));
                
                if (closestPoints.length < 10) {
                    closestPoints.push({...d, distance: dist});
                    if (dist > maxDist) maxDist = dist;
                } else if (dist < maxDist) {
                    // Replace the furthest point in our current set
                    const maxIndex = closestPoints.findIndex(p => p.distance === maxDist);
                    closestPoints[maxIndex] = {...d, distance: dist};
                    
                    // Find new maxDist
                    maxDist = Math.max(...closestPoints.map(p => p.distance));
                }
            });
            
            // Sort the closest points
            closestPoints.sort((a, b) => a.distance - b.distance);
            
            // Mark closest points as highlighted
            closestPoints.forEach(point => {
                const dataPoint = data.find(d => d.X === point.X && d.Y === point.Y);
                if (dataPoint) dataPoint.highlighted = true;
            });
            
            // Update the visual display efficiently
            g.selectAll("circle")
                .attr("fill", d => d.highlighted ? "#f1a7cd" : "#7e212a")
                .attr("r", d => d.highlighted ? HIGHLIGHT_RADIUS : POINT_RADIUS);
            
            // Update sidebar
            updateSidebar(closestPoints);
            
            // Reset processing flag
            isProcessing = false;
        }
        
        // Function to update sidebar content
        function updateSidebar(stores) {
            const container = document.getElementById("closest-stores");
            
            // Create a document fragment to minimize DOM manipulations
            const fragment = document.createDocumentFragment();
            
            // Hide instructions when we have results
            document.getElementById("map-instructions").style.display = "none";
            
            stores.forEach((store, index) => {
                const storeElement = document.createElement("div");
                storeElement.className = "store-item";
                
                const nameElement = document.createElement("div");
                nameElement.className = "store-name";
                nameElement.textContent = `${index + 1}. ${store.Store_Name}`;
                
                const addressElement = document.createElement("div");
                addressElement.className = "store-address";
                addressElement.textContent = `${store.Store_Street_Address}, ${store.City}, ${store.State} ${store.Zip_Code}`;
                
                const typeElement = document.createElement("div");
                typeElement.className = "store-type";
                typeElement.textContent = `Type: ${store.Store_Type}`;
                
                storeElement.appendChild(nameElement);
                storeElement.appendChild(addressElement);
                storeElement.appendChild(typeElement);
                fragment.appendChild(storeElement);
            });
            
            // Clear and update the container in one operation
            container.innerHTML = "";
            container.appendChild(fragment);
        }
    </script>
</body>
</html>